var J=Object.defineProperty;var U=(u,s,e)=>s in u?J(u,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[s]=e;var p=(u,s,e)=>(U(u,typeof s!="symbol"?s+"":s,e),e);import{f as O,j as Z,T as _,W as $,P as E,k as ss,V as es}from"./Replay.c9641c9b.js";import{d as K,L as T,c as f,b as j,V as ts,P as k}from"./PositionIndex.ce0183fb.js";const H=O({group:_.f32});class l extends K{findCollisionWith(s,e={}){const o=this.findAABB(this.constructor.aabb),i=s.findAABB(this.constructor.otherAabb);if(!!this.detectAABBOverlap(o,i)){if(this.AreaRectangle.hasComponent()){if(s.AreaRectangle.hasComponent())return!0}else if(this.AreaCapsule.hasComponent()){if(s.AreaCapsule.hasComponent())return this.findCapsuleVsCapsuleCollsionWith(s,e)}else if(this.AreaCircle.hasComponent()&&s.AreaCircle.hasComponent())return this.findCircleVsCircleCollisionWith(s,e)}}detectAABBOverlap(s,e){const{x:o,y:i,width:n,height:t}=s,{x:a,y:r,width:d,height:c}=e;return o<a+d&&o+n>a&&i<r+c&&i+t>r}findCircleVsCircleCollisionWith(s,e={}){const{capsuleLine:o,otherCapsuleLine:i,nearestCapsulePoints:n,capsuleCollisionNormal:t,capsuleCollisionPoint:a}=this.constructor,{Position:r,AreaCircle:{radius:d}}=this,{Position:c,AreaCircle:{radius:C}}=s,g=Math.pow(d+C,2);if(r.distanceToSquared(c)<g)return t.clone(r).subtract(c).normalize(),e.separation=r.distanceTo(c),e.collisionNormal={...t},e.collisionCenter={...r},e.otherCollisionCenter={...c},e.edge={...a.copy(t).scaleBy(-d).add(r)},e.otherEdge={...a.copy(t).scaleBy(C).add(c)},e}findCapsuleVsCapsuleCollsionWith(s,e={}){const{capsuleLine:o,otherCapsuleLine:i,nearestCapsulePoints:n,capsuleCollisionNormal:t,capsuleCollisionPoint:a}=this.constructor,{radius:r}=this.AreaCapsule,{radius:d}=s.AreaCapsule;this.findLineForCapsule(o),s.findLineForCapsule(i),o.findClosestPointsBetweenLines(i,n);const c=n.lengthSquared();if(!(c>Math.pow(r+d,2)))return t.clone(n.p0).subtract(n.p1).normalize(),e.separation=Math.sqrt(c),e.collisionNormal={...t},e.collisionCenter={...n.p0},e.otherCollisionCenter={...n.p1},e.edge={...a.copy(t).scaleBy(-r).add(n.p0)},e.otherEdge={...a.copy(t).scaleBy(d).add(n.p1)},e}findLineForCapsule(s=new T){const{r:e}=this.Position,{radius:o,length:i}=this.AreaCapsule,n=i/2-o;return s.p0.set(0,0-n).rotate(e),s.p0.add(this.Position),s.p1.set(0,n).rotate(e),s.p1.add(this.Position),s}}p(l,"components",{...K.components,Collidable:H}),p(l,"componentProxyClasses",{...K.componentProxyClasses}),p(l,"aabb",{}),p(l,"otherAabb",{}),p(l,"capsuleLine",new T),p(l,"otherCapsuleLine",new T),p(l,"nearestCapsulePoints",new T),p(l,"capsuleCollisionNormal",new f),p(l,"capsuleCollisionPoint",new f);class F extends ${initStore(){return{pairs:new Map,previousPairs:new Map,collisions:new Map,previousCollisions:new Map}}clear(){const s=this._store.pairs,e=this._store.collisions;this._store.pairs=this._store.previousPairs,this._store.collisions=this._store.previousCollisions,this._store.previousPairs=s,this._store.previousCollisions=e,this._store.pairs.clear(),this._store.collisions.clear()}pairKey(s,e){return[s,e].sort().join(":")}hasPair(s,e){return this.pairs.has(this.pairKey(s,e))}stillHasPair(s,e){return this.previousPairs.has(this.pairKey(s,e))}*allPairs(){for(const[s,e]of this.pairs.entries())yield[...s.split(":"),e]}getPair(s,e){return this.pairs(this.pairKey(s,e))}get(s){return this.collisions.get(s)}add(s,e,o={}){const i=this.pairKey(s,e),n=this.pairs;if(n.has(i))return;n.set(i,o);const t=this.collisions;t.has(s)||t.set(s,new Set),t.get(s).add(e),t.has(e)||t.set(e,new Set),t.get(e).add(s)}}p(F,"storeKey",Symbol("collisions")),p(F,"attributes",["pairs","collisions","previousPairs","previousCollisions"]);const y=new F,os=Z([E,H]),cs=(u={})=>{const s=new l,e=new l;return o=>{j.using(o),y.using(o).clear();for(const i of os(o)){s.using(i,o);const n=j.findByEntity(i).filter(t=>ss(o,H,t)&&!y.hasPair(i,t));for(const t of n){e.using(t,o);const a=s.findCollisionWith(e);a&&y.add(i,t,a)}}return o}},ls=(u={})=>{const s=new l,e=new l;return o=>{if(!o||!o.debug)return o;const i=o.debugGraphics;y.using(o);for(const[n,t,a]of y.allPairs()){s.using(n,o),e.using(t,o);const r=y.stillHasPair(n,t)?.5:1;i.lineStyle(2,16720418,r);const{separationSq:d,collisionNormal:c,collisionCenter:C,otherCollisionCenter:g,edge:h,otherEdge:m}=a;i.drawCircle(h.x,h.y,2),i.drawCircle(m.x,m.y,2),i.drawCircle(C.x,C.y,2),i.drawCircle(g.x,g.y,2),i.moveTo(C.x,C.y),i.lineTo(g.x,g.y)}return o}},is=O({mass:_.f32,restitution:_.f32,immobile:_.f32});class v extends l{}p(v,"components",{...l.components,Bounce:is,Velocity:es}),p(v,"componentProxyClasses",{...l.componentProxyClasses,Velocity:ts});const us=(u={})=>{const s=new v,e=new v,o=h=>{y.using(h);for(const[m,B,P]of y.allPairs())s.using(m,h),e.using(B,h),s.Bounce.hasComponent()&&e.Bounce.hasComponent()&&(y.stillHasPair(m,B)||d(u,P),g(u,P));return h},i=new f,n=new f,t=new f,a=new f,r=new f;function d(h={},m){const{separation:B,collisionNormal:P,center:W,otherCenter:M,edge:z,otherEdge:N}=m,{Position:q,Velocity:V,Bounce:x}=s,{Position:S,Velocity:b,Bounce:A}=e;let w;P?w=i.copy(P).angle():w=0-q.angleTo(S),n.copy(V).rotate(w),t.copy(b).rotate(w);const L=x.mass||1,D=A.mass||1,R=L+D,Q=L-D,I=D-L;a.set(Q/R*n.x+2*D/R*t.x,n.y),r.set(2*L/R*n.x+I/R*t.x,t.y);const X=x.restitution||1,Y=A.restitution||1,G=X*Y;a.scaleBy(G),r.scaleBy(G),a.rotate(-w),r.rotate(-w),x.immobile||V.copy(a),A.immobile||b.copy(r)}const c=new f,C=new f;function g({separationFactor:h=5}={},m){const{Position:B,Velocity:P,Bounce:W}=s,{Position:M,Velocity:z,Bounce:N}=e,q=new k().copy(m.edge),V=new k().copy(m.otherEdge);c.copy(B).subtract(M);const x=c.magnitude(),S=B.distanceTo(q)+M.distanceTo(V);if(x>=S)return;c.normalize(),C.copy(c);const b=W.mass+N.mass,A=h*(S-x);P.add(c.scaleBy(A*((b-W.mass)/b))),z.add(C.scaleBy(-A*((b-N.mass)/b)))}return o},ps=(u={})=>s=>(!s||!s.debug||s.debugGraphics,s);export{is as B,H as C,ls as a,us as b,cs as c,y as d,ps as e};
